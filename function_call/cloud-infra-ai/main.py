import click
import json
import boto3
import botocore
from get_ami_releases import get_ecs_amis_releases_info
import xmltodict

# Initialize models
model_id ='anthropic.claude-3-sonnet-20240229-v1:0' 
session = boto3.Session()
aws_region = 'us-west-2'

# Config to avoid timeouts when using long prompts
config = botocore.config.Config(
    read_timeout=1800,
    connect_timeout=1800,
    retries={"max_attempts": 0}
)
bedrock_client = session.client(service_name='bedrock-runtime', region_name=aws_region,config=config)

### Utils
def invoke(function):
    print(f"App: Invoking function {function['name']}")
    if function["name"] == "get_ecs_amis_releases_info":
        result = get_ecs_amis_releases_info(function["parameters"]["image_ids"]["name"])
        return f"<get_ecs_amis_releases_info>{result}</get_ecs_amis_releases_info>"

### CLI

@click.group()
def cli():
    pass

@cli.command()  
@click.option('--terraform-plan', help="Terraform json plan file path", required=True)
def eval(terraform_plan):
    # Getting the resources
    click.echo('Evaluating plan...')
    with open(terraform_plan) as t_plan_file:
        t_plan_json = json.loads(t_plan_file.read())

    # Get modifications to be done
    prompt = f"""
    List the resources that will be created, modified or deleted in the following terraform plan using the following rules:
    1. Think step by step using <thinking></thining> tags
    2. For AMI changes, include the old and new AMI ID
    3. The result should be within <result></result> tags
    <terraform_plan>
    {t_plan_json["resource_changes"]}
    </terraform_plan>
    """
    request_body = { 
        "anthropic_version": "bedrock-2023-05-31",
        'max_tokens': 4096,
        "system": "You are an assistant that helps reading infrastructure changes from JSON objects generated by terraform",
        "temperature":0,
        "stop_sequences":["</result>"],
        "messages": [
            {
            "role": "user",
            "content": [
                    {
                    "type": "text",
                    "text": prompt
                    }
                ]
            },{
            "role": "assistant",
            "content": [
                    {
                    "type": "text",
                    "text": "<thinking>"
                    }
                ]
            }
        ]
    }
    response = bedrock_client.invoke_model_with_response_stream(
        body=json.dumps(request_body),
        modelId=model_id, 
        accept='application/json', 
        contentType='application/json'
    )
    analysis_response_text = ""
    for event in response.get("body"):
        response = json.loads(event['chunk']['bytes'].decode())
        if response['type'] == 'content_block_start':
            print(response['content_block']['text'],end='')
            analysis_response_text += response['content_block']['text']
        elif response['type'] == 'content_block_delta':
            print(response['delta']['text'],end='')
            analysis_response_text += response['delta']['text']
    
    # Remove anything else but the result (e.g., <thinking> tags)
    analysis_response_text = analysis_response_text.split("<result>")[1]

    # Evaluate AMIs per analysis
    prompt = f"""
        Find additional details of infrastructure changes using the following rules
        1. For Amazon machine image (AMI or image_id) modifications, compare the old AMI information against the new AMI, including linux kernel, docker and ecs agent.
        
        If you don't know the AMI image_id information, return the following function before answering. 
        <example>
        <function>
        <name>get_ecs_amis_releases_info</name>
        <parameters>
            <image_ids type="array" description="Amazon machine image (AMI) ids">
                <name>AMI 1 id</name>
                <name>AMI 2 id</name>
            </image_ids>
        </parameters>
        </function>
        </example>

        2. Wrap all functions you need to be called in <function></function> tabs within <invoke></invoke> tags
        3. Think step by step using <thinking></thinking> tags
        4. Output should be in <result></result> tags
        Here is an example of how the output should be:
        <example>
            <result>
            List that will be created, modified or deleted
            ## Current AMI ID - AMI NAME
            * kernel
            * docker version
            * ECS agent

            ## New AMI ID - AMI NAME
            * kernel
            * docker version
            * ECS agent
            </result>
        </example>
        Given the following analysis, compare any old with new AMIs:
        <analysis>{analysis_response_text}</analysis>
        """
    request_body = { 
        "anthropic_version": "bedrock-2023-05-31",
        'max_tokens': 4096,
        "system": "You are an assistant that helps reading infrastructure changes from JSON objects generated by terraform",
        "temperature":0,
        "stop_sequences":["</invoke>"],
        "messages": [
            {
            "role": "user",
            "content": [
                    {
                    "type": "text",
                    "text": prompt
                    }
                ]
            },{
            "role": "assistant",
            "content": [
                    {
                    "type": "text",
                    "text": "<thinking>"
                    }
                ]
            }
        ]
    }
    response = bedrock_client.invoke_model_with_response_stream(
        body=json.dumps(request_body),
        modelId=model_id, 
        accept='application/json', 
        contentType='application/json'
    )
    response_text = ""
    for event in response.get("body"):
        response = json.loads(event['chunk']['bytes'].decode())
        if response['type'] == 'content_block_start':
            print(response['content_block']['text'],end='')
            response_text += response['content_block']['text']
        elif response['type'] == 'content_block_delta':
            print(response['delta']['text'],end='')
            response_text += response['delta']['text']

    # Check if there is an invoke function request from Claude
    while True:
        if "<invoke>" in response_text:
            invoke_result = "<invoke_results>"
            functions_str = response_text.split("<invoke>")[1]
            
            functions_dict = xmltodict.parse(f"<invoke>{functions_str}</invoke>")
            if type(functions_dict["invoke"]) == type([]):
                for function in functions_dict["invoke"]:
                    invoke_result += invoke(function["function"])
            else:
                invoke_result += invoke(functions_dict["invoke"]["function"])
            invoke_result += "</invoke_results>"
            
            print(invoke_result)
            
            request_body = { 
                "anthropic_version": "bedrock-2023-05-31",
                'max_tokens': 4096,
                "system": "You are an assistant that helps reading infrastructure changes from JSON objects generated by terraform",
                "temperature":0,
                "stop_sequences":["</invoke>","</result>"],
                "messages": [
                    {
                    "role": "user",
                    "content": [
                            {
                            "type": "text",
                            "text": prompt
                            }
                        ]
                    },{
                    "role": "assistant",
                    "content": [
                            {
                            "type": "text",
                            "text": f"<thinking>{response_text}\n</invoke>{invoke_result}<result>" # Fix closing tags 
                            }
                        ]
                    }
                ]
            }
            response = bedrock_client.invoke_model_with_response_stream(
                body=json.dumps(request_body),
                modelId=model_id, 
                accept='application/json', 
                contentType='application/json'
            )
            
            response_text = ""
            for event in response.get("body"):
                response = json.loads(event['chunk']['bytes'].decode())
                if response['type'] == 'content_block_start':
                    print(response['content_block']['text'],end='')
                    response_text += response['content_block']['text']
                elif response['type'] == 'content_block_delta':
                    print(response['delta']['text'],end='')
                    response_text += response['delta']['text']
            
        else:
            print("\n\n===== Final analysis ====")
            print(analysis_response_text)
            print(response_text)
            break

    
if __name__ == '__main__':
    cli()